#### 使用构造函数

当下列事件之一发生时，将调用析构函数：
使用 delete 运算符显式解除分配了使用 new 运算符分配的对象。 使用 delete 运算符解除分配对象时，将为“大多数派生对象”或为属于完整对象，但不是表示基类的子对象的对象释放内存。 此“大多数派生对象”解除分配一定仅对虚拟析构函数有效。 在类型信息与实际对象的基础类型不匹配的多重继承情况下，取消分配可能失败。
具有块范围的本地（自动）对象超出范围。
临时对象的生存期结束。
程序结束，并且存在全局或静态对象。
使用析构函数的完全限定名显式调用了析构函数

从析构函数调用虚函数时，调用的函数是当前正在销毁的类的函数。

析构函数的使用有两个限制。 第一个限制是您无法采用析构函数的地址。 第二个是派生类不会继承其基类的析构函数。 相反，如前所释，它们始终重写基类的析构函数。


#### 析构的顺序

当对象超出范围或被删除时，其完整析构中的事件序列如下所示：
1. 将调用该类的析构函数，并且会执行该析构函数的主体。
2. 按照非静态成员对象的析构函数在类声明中的显示顺序的相反顺序调用这些函数。 用于这些成员的构造的可选成员优化列表不影响构造或析构的顺序。
3. 非虚拟基类的析构函数以声明的相反顺序被调用。
4. 虚拟基类的析构函数以声明的相反顺序被调用。


#### 文档
- [微软文档](https://msdn.microsoft.com/zh-cn/library/6t4fe76c)